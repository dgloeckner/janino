package org.codehaus.janino.tests;

import java.io.StringReader;
import java.util.Arrays;

import org.codehaus.commons.compiler.CompilerFactoryFactory;
import org.codehaus.commons.compiler.IClassBodyEvaluator;
import org.codehaus.commons.compiler.ICompilerFactory;
import org.codehaus.commons.compiler.ISimpleCompiler;
import org.junit.Test;

/**
 * Generates a class with a very big method with lots of assignments.
 * All Janino versions with <a href="https://github.com/janino-compiler/janino/commit/91cfcb90869db5efeb53c1fd13b9d6cfa6374165#diff-9b50ca96aaf59d113be01aeb317c57e189548be8d8d234a08202a6168dd64c7e">
 * enabled StackMapTable</a> produce very large byte code for the test case provided here.
 * <p>
 * On newer JVMs this causes the JVM to crash when the generated class is loaded.
 *
 * <i>How bad is it?</i> Comparing the size of generated byte code between javac and Janino > 3.0.11 we see
 * that the byte code produced by Janino is 350 times bigger than the code from javac!
 *
 * <i>Note: </i> Java 16 introduced some improvements for the metaspace and the related memory management.
 * See <a href="https://openjdk.org/jeps/387">JEP 387: Elastic Metaspace</a>
 */
public class BigMethodTest {

	@Test
	public void testGenerateAndLoadBSmallMethod() throws Exception {
		String body = getClassBody(10);
		Nukable obj = createObject(body);
		System.out.println("Got the object " + obj);
		System.out.println("Invoking nuke method");
		System.out.println(Arrays.toString(obj.nuke()));
	}

	@Test
	public void testGenerateAndLoadBigMethod() throws Exception {
		// Generate inefficient code with lots of assignments.
		// Breaks JVMs >=16 when using more than 840 assignments:
		// #  Internal Error (metaspaceArena.cpp:88), pid=12308, tid=6659
		// #  guarantee(requested_word_size <= chunklevel::MAX_CHUNK_WORD_SIZE) failed: Requested size too large (756627) - max allowed size per allocation is 524288.
		String body = getClassBody(1000);
		Nukable obj = createObject(body);
		System.out.println("Got the object " + obj);
		System.out.println("Invoking nuke method");
		System.out.println(Arrays.toString(obj.nuke()));
	}

	private Nukable createObject(String body) throws Exception {
		ICompilerFactory compilerFactory = CompilerFactoryFactory.getDefaultCompilerFactory(this.getClass().getClassLoader());
		ISimpleCompiler compiler = compilerFactory.newSimpleCompiler();

		// Instantiate an object from the generated class.
		IClassBodyEvaluator cbe = compilerFactory.newClassBodyEvaluator();
		cbe.setClassName("Nuke");
		cbe.setImplementedInterfaces(new Class[]{Nukable.class});
		cbe.setParentClassLoader(this.getClass().getClassLoader());
		cbe.setDefaultImports("java.util.Arrays");
		return (Nukable) cbe.createInstance(new StringReader(body));
	}

	private static String getClassBody(int numAssignments) {
		String template = "public Object[] nuke() {\n"
				+ "\tString bloat = \"some_bloat\";\n"
				+ "\t//Lots of variables\n"
				+ "%s"
				+ "\t//Big array initialization\n"
				+ "\treturn new Object[]\n"
				+ "\t{\n"
				+ "%s"
				+ "\t};\n"
				+ "}\n"
				+ "\n"
				+ ""
				+ "public static void main(String[] args) throws Exception {"
				+ "\tSystem.out.println(Arrays.toString(new Nuke().nuke()));"
				+ "}";
		StringBuilder assignments = new StringBuilder();
		StringBuilder appends = new StringBuilder();
		for (int i = 0; i < numAssignments; i++) {
			assignments.append(String.format("\tfinal String current%s = bloat;\n", i));
			appends.append(String.format("\t\tcurrent%s", i));
			//appends.append(String.format("\t\t\"current%s\"", i));
			if (i < numAssignments - 1) {
				appends.append(",");
			}
			appends.append("\n");
		}
		return String.format(template, assignments, appends);
	}

	public interface Nukable {
		Object[] nuke();
	}
}
